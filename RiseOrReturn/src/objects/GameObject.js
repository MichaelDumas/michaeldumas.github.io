import Vector from"../../lib/Vector.js";import{getCollisionDirection}from"../../lib/CollisionHelpers.js";import Hitbox from"../../lib/Hitbox.js";import Direction from"../enums/Direction.js";import{context,DEBUG}from"../globals.js";export default class GameObject{constructor(i,t){this.dimensions=i,this.position=t,this.hitboxOffsets=new Hitbox,this.hitbox=new Hitbox(this.position.x+this.hitboxOffsets.position.x,this.position.y+this.hitboxOffsets.position.y,this.dimensions.x+this.hitboxOffsets.dimensions.x,this.dimensions.y+this.hitboxOffsets.dimensions.y),this.sprites=[],this.currentFrame=0,this.cleanUp=!1,this.renderPriority=0,this.isSolid=!1,this.isCollidable=!1,this.isConsumable=!1,this.wasCollided=!1,this.wasConsumed=!1}update(i){}render(i={x:0,y:0}){const t=this.position.x+i.x,o=this.position.y+i.y;this.sprites[this.currentFrame].render(Math.floor(t),Math.floor(o)),DEBUG&&this.hitbox.render(context)}onConsume(i){this.wasConsumed=!0}onCollision(i){if(this.isSolid)switch(this.getEntityCollisionDirection(i.hitbox)){case Direction.Up:i.position.y=this.hitbox.position.y-Math.abs(i.position.y-i.hitbox.position.y)-i.hitbox.dimensions.y;break;case Direction.Down:i.position.y=this.hitbox.position.y+this.hitbox.dimensions.y-Math.abs(i.position.y-i.hitbox.position.y);break;case Direction.Left:i.position.x=this.hitbox.position.x-Math.abs(i.position.x-i.hitbox.position.x)-i.hitbox.dimensions.x;break;case Direction.Right:i.position.x=this.hitbox.position.x+this.hitbox.dimensions.x-Math.abs(i.position.x-i.hitbox.position.x)}this.wasCollided||(this.wasCollided=!0)}didCollideWithEntity(i){return this.hitbox.didCollide(i)}getEntityCollisionDirection(i){return getCollisionDirection(this.hitbox.position.x,this.hitbox.position.y,this.hitbox.dimensions.x,this.hitbox.dimensions.y,i.position.x,i.position.y,i.dimensions.x,i.dimensions.y)}}