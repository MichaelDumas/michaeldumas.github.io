const util=require("./util"),binarySearch=require("./binary-search"),ArraySet=require("./array-set").ArraySet,base64VLQ=require("./base64-vlq"),readWasm=require("../lib/read-wasm"),wasm=require("./wasm"),INTERNAL=Symbol("smcInternal");class SourceMapConsumer{constructor(e,n){return e==INTERNAL?Promise.resolve(this):_factory(e,n)}static initialize(e){readWasm.initialize(e["lib/mappings.wasm"])}static fromSourceMap(e,n){return _factoryBSM(e,n)}static with(e,n,r){let t=null;return new SourceMapConsumer(e,n).then((e=>(t=e,r(e)))).then((e=>(t&&t.destroy(),e)),(e=>{throw t&&t.destroy(),e}))}_parseMappings(e,n){throw new Error("Subclasses must implement _parseMappings")}eachMapping(e,n,r){throw new Error("Subclasses must implement eachMapping")}allGeneratedPositionsFor(e){throw new Error("Subclasses must implement allGeneratedPositionsFor")}destroy(){throw new Error("Subclasses must implement destroy")}}SourceMapConsumer.prototype._version=3,SourceMapConsumer.GENERATED_ORDER=1,SourceMapConsumer.ORIGINAL_ORDER=2,SourceMapConsumer.GREATEST_LOWER_BOUND=1,SourceMapConsumer.LEAST_UPPER_BOUND=2,exports.SourceMapConsumer=SourceMapConsumer;class BasicSourceMapConsumer extends SourceMapConsumer{constructor(e,n){return super(INTERNAL).then((r=>{let t=e;"string"==typeof e&&(t=util.parseSourceMapInput(e));const s=util.getArg(t,"version");let o=util.getArg(t,"sources");const i=util.getArg(t,"names",[]);let u=util.getArg(t,"sourceRoot",null);const a=util.getArg(t,"sourcesContent",null),l=util.getArg(t,"mappings"),c=util.getArg(t,"file",null);if(s!=r._version)throw new Error("Unsupported version: "+s);return u&&(u=util.normalize(u)),o=o.map(String).map(util.normalize).map((function(e){return u&&util.isAbsolute(u)&&util.isAbsolute(e)?util.relative(u,e):e})),r._names=ArraySet.fromArray(i.map(String),!0),r._sources=ArraySet.fromArray(o,!0),r._absoluteSources=r._sources.toArray().map((function(e){return util.computeSourceURL(u,e,n)})),r.sourceRoot=u,r.sourcesContent=a,r._mappings=l,r._sourceMapURL=n,r.file=c,r._computedColumnSpans=!1,r._mappingsPtr=0,r._wasm=null,wasm().then((e=>(r._wasm=e,r)))}))}_findSourceIndex(e){let n=e;if(null!=this.sourceRoot&&(n=util.relative(this.sourceRoot,n)),this._sources.has(n))return this._sources.indexOf(n);for(let n=0;n<this._absoluteSources.length;++n)if(this._absoluteSources[n]==e)return n;return-1}static fromSourceMap(e,n){return new BasicSourceMapConsumer(e.toString())}get sources(){return this._absoluteSources.slice()}_getMappingsPtr(){return 0===this._mappingsPtr&&this._parseMappings(this._mappings,this.sourceRoot),this._mappingsPtr}_parseMappings(e,n){const r=e.length,t=this._wasm.exports.allocate_mappings(r),s=new Uint8Array(this._wasm.exports.memory.buffer,t,r);for(let n=0;n<r;n++)s[n]=e.charCodeAt(n);const o=this._wasm.exports.parse_mappings(t);if(!o){const e=this._wasm.exports.get_last_error();let n=`Error parsing mappings (code ${e}): `;switch(e){case 1:n+="the mappings contained a negative line, column, source index, or name index";break;case 2:n+="the mappings contained a number larger than 2**32";break;case 3:n+="reached EOF while in the middle of parsing a VLQ";break;case 4:n+="invalid base 64 character while parsing a VLQ";break;default:n+="unknown error code"}throw new Error(n)}this._mappingsPtr=o}eachMapping(e,n,r){const t=n||null,s=r||SourceMapConsumer.GENERATED_ORDER,o=this.sourceRoot;this._wasm.withMappingCallback((n=>{null!==n.source&&(n.source=this._sources.at(n.source),n.source=util.computeSourceURL(o,n.source,this._sourceMapURL),null!==n.name&&(n.name=this._names.at(n.name))),e.call(t,n)}),(()=>{switch(s){case SourceMapConsumer.GENERATED_ORDER:this._wasm.exports.by_generated_location(this._getMappingsPtr());break;case SourceMapConsumer.ORIGINAL_ORDER:this._wasm.exports.by_original_location(this._getMappingsPtr());break;default:throw new Error("Unknown order of iteration.")}}))}allGeneratedPositionsFor(e){let n=util.getArg(e,"source");const r=util.getArg(e,"line"),t=e.column||0;if(n=this._findSourceIndex(n),n<0)return[];if(r<1)throw new Error("Line numbers must be >= 1");if(t<0)throw new Error("Column numbers must be >= 0");const s=[];return this._wasm.withMappingCallback((e=>{let n=e.lastGeneratedColumn;this._computedColumnSpans&&null===n&&(n=1/0),s.push({line:e.generatedLine,column:e.generatedColumn,lastColumn:n})}),(()=>{this._wasm.exports.all_generated_locations_for(this._getMappingsPtr(),n,r-1,"column"in e,t)})),s}destroy(){0!==this._mappingsPtr&&(this._wasm.exports.free_mappings(this._mappingsPtr),this._mappingsPtr=0)}computeColumnSpans(){this._computedColumnSpans||(this._wasm.exports.compute_column_spans(this._getMappingsPtr()),this._computedColumnSpans=!0)}originalPositionFor(e){const n={generatedLine:util.getArg(e,"line"),generatedColumn:util.getArg(e,"column")};if(n.generatedLine<1)throw new Error("Line numbers must be >= 1");if(n.generatedColumn<0)throw new Error("Column numbers must be >= 0");let r,t=util.getArg(e,"bias",SourceMapConsumer.GREATEST_LOWER_BOUND);if(null==t&&(t=SourceMapConsumer.GREATEST_LOWER_BOUND),this._wasm.withMappingCallback((e=>r=e),(()=>{this._wasm.exports.original_location_for(this._getMappingsPtr(),n.generatedLine-1,n.generatedColumn,t)})),r&&r.generatedLine===n.generatedLine){let e=util.getArg(r,"source",null);null!==e&&(e=this._sources.at(e),e=util.computeSourceURL(this.sourceRoot,e,this._sourceMapURL));let n=util.getArg(r,"name",null);return null!==n&&(n=this._names.at(n)),{source:e,line:util.getArg(r,"originalLine",null),column:util.getArg(r,"originalColumn",null),name:n}}return{source:null,line:null,column:null,name:null}}hasContentsOfAllSources(){return!!this.sourcesContent&&(this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some((function(e){return null==e})))}sourceContentFor(e,n){if(!this.sourcesContent)return null;const r=this._findSourceIndex(e);if(r>=0)return this.sourcesContent[r];let t,s=e;if(null!=this.sourceRoot&&(s=util.relative(this.sourceRoot,s)),null!=this.sourceRoot&&(t=util.urlParse(this.sourceRoot))){const e=s.replace(/^file:\/\//,"");if("file"==t.scheme&&this._sources.has(e))return this.sourcesContent[this._sources.indexOf(e)];if((!t.path||"/"==t.path)&&this._sources.has("/"+s))return this.sourcesContent[this._sources.indexOf("/"+s)]}if(n)return null;throw new Error('"'+s+'" is not in the SourceMap.')}generatedPositionFor(e){let n=util.getArg(e,"source");if(n=this._findSourceIndex(n),n<0)return{line:null,column:null,lastColumn:null};const r={source:n,originalLine:util.getArg(e,"line"),originalColumn:util.getArg(e,"column")};if(r.originalLine<1)throw new Error("Line numbers must be >= 1");if(r.originalColumn<0)throw new Error("Column numbers must be >= 0");let t,s=util.getArg(e,"bias",SourceMapConsumer.GREATEST_LOWER_BOUND);if(null==s&&(s=SourceMapConsumer.GREATEST_LOWER_BOUND),this._wasm.withMappingCallback((e=>t=e),(()=>{this._wasm.exports.generated_location_for(this._getMappingsPtr(),r.source,r.originalLine-1,r.originalColumn,s)})),t&&t.source===r.source){let e=t.lastGeneratedColumn;return this._computedColumnSpans&&null===e&&(e=1/0),{line:util.getArg(t,"generatedLine",null),column:util.getArg(t,"generatedColumn",null),lastColumn:e}}return{line:null,column:null,lastColumn:null}}}BasicSourceMapConsumer.prototype.consumer=SourceMapConsumer,exports.BasicSourceMapConsumer=BasicSourceMapConsumer;class IndexedSourceMapConsumer extends SourceMapConsumer{constructor(e,n){return super(INTERNAL).then((r=>{let t=e;"string"==typeof e&&(t=util.parseSourceMapInput(e));const s=util.getArg(t,"version"),o=util.getArg(t,"sections");if(s!=r._version)throw new Error("Unsupported version: "+s);r._sources=new ArraySet,r._names=new ArraySet,r.__generatedMappings=null,r.__originalMappings=null,r.__generatedMappingsUnsorted=null,r.__originalMappingsUnsorted=null;let i={line:-1,column:0};return Promise.all(o.map((e=>{if(e.url)throw new Error("Support for url field in sections not implemented.");const r=util.getArg(e,"offset"),t=util.getArg(r,"line"),s=util.getArg(r,"column");if(t<i.line||t===i.line&&s<i.column)throw new Error("Section offsets must be ordered and non-overlapping.");i=r;return new SourceMapConsumer(util.getArg(e,"map"),n).then((e=>({generatedOffset:{generatedLine:t+1,generatedColumn:s+1},consumer:e})))}))).then((e=>(r._sections=e,r)))}))}get _generatedMappings(){return this.__generatedMappings||this._sortGeneratedMappings(),this.__generatedMappings}get _originalMappings(){return this.__originalMappings||this._sortOriginalMappings(),this.__originalMappings}get _generatedMappingsUnsorted(){return this.__generatedMappingsUnsorted||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappingsUnsorted}get _originalMappingsUnsorted(){return this.__originalMappingsUnsorted||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappingsUnsorted}_sortGeneratedMappings(){const e=this._generatedMappingsUnsorted;e.sort(util.compareByGeneratedPositionsDeflated),this.__generatedMappings=e}_sortOriginalMappings(){const e=this._originalMappingsUnsorted;e.sort(util.compareByOriginalPositions),this.__originalMappings=e}get sources(){const e=[];for(let n=0;n<this._sections.length;n++)for(let r=0;r<this._sections[n].consumer.sources.length;r++)e.push(this._sections[n].consumer.sources[r]);return e}originalPositionFor(e){const n={generatedLine:util.getArg(e,"line"),generatedColumn:util.getArg(e,"column")},r=binarySearch.search(n,this._sections,(function(e,n){const r=e.generatedLine-n.generatedOffset.generatedLine;return r||e.generatedColumn-n.generatedOffset.generatedColumn})),t=this._sections[r];return t?t.consumer.originalPositionFor({line:n.generatedLine-(t.generatedOffset.generatedLine-1),column:n.generatedColumn-(t.generatedOffset.generatedLine===n.generatedLine?t.generatedOffset.generatedColumn-1:0),bias:e.bias}):{source:null,line:null,column:null,name:null}}hasContentsOfAllSources(){return this._sections.every((function(e){return e.consumer.hasContentsOfAllSources()}))}sourceContentFor(e,n){for(let n=0;n<this._sections.length;n++){const r=this._sections[n].consumer.sourceContentFor(e,!0);if(r)return r}if(n)return null;throw new Error('"'+e+'" is not in the SourceMap.')}generatedPositionFor(e){for(let n=0;n<this._sections.length;n++){const r=this._sections[n];if(-1===r.consumer._findSourceIndex(util.getArg(e,"source")))continue;const t=r.consumer.generatedPositionFor(e);if(t){return{line:t.line+(r.generatedOffset.generatedLine-1),column:t.column+(r.generatedOffset.generatedLine===t.line?r.generatedOffset.generatedColumn-1:0)}}}return{line:null,column:null}}_parseMappings(e,n){const r=this.__generatedMappingsUnsorted=[],t=this.__originalMappingsUnsorted=[];for(let e=0;e<this._sections.length;e++){const n=this._sections[e],s=[];n.consumer.eachMapping((e=>s.push(e)));for(let e=0;e<s.length;e++){const o=s[e];let i=util.computeSourceURL(n.consumer.sourceRoot,null,this._sourceMapURL);this._sources.add(i),i=this._sources.indexOf(i);let u=null;o.name&&(this._names.add(o.name),u=this._names.indexOf(o.name));const a={source:i,generatedLine:o.generatedLine+(n.generatedOffset.generatedLine-1),generatedColumn:o.generatedColumn+(n.generatedOffset.generatedLine===o.generatedLine?n.generatedOffset.generatedColumn-1:0),originalLine:o.originalLine,originalColumn:o.originalColumn,name:u};r.push(a),"number"==typeof a.originalLine&&t.push(a)}}}eachMapping(e,n,r){const t=n||null;let s;switch(r||SourceMapConsumer.GENERATED_ORDER){case SourceMapConsumer.GENERATED_ORDER:s=this._generatedMappings;break;case SourceMapConsumer.ORIGINAL_ORDER:s=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}const o=this.sourceRoot;s.map((function(e){let n=null;return null!==e.source&&(n=this._sources.at(e.source),n=util.computeSourceURL(o,n,this._sourceMapURL)),{source:n,generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:null===e.name?null:this._names.at(e.name)}}),this).forEach(e,t)}_findMapping(e,n,r,t,s,o){if(e[r]<=0)throw new TypeError("Line must be greater than or equal to 1, got "+e[r]);if(e[t]<0)throw new TypeError("Column must be greater than or equal to 0, got "+e[t]);return binarySearch.search(e,n,s,o)}allGeneratedPositionsFor(e){const n=util.getArg(e,"line"),r={source:util.getArg(e,"source"),originalLine:n,originalColumn:util.getArg(e,"column",0)};if(r.source=this._findSourceIndex(r.source),r.source<0)return[];if(r.originalLine<1)throw new Error("Line numbers must be >= 1");if(r.originalColumn<0)throw new Error("Column numbers must be >= 0");const t=[];let s=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",util.compareByOriginalPositions,binarySearch.LEAST_UPPER_BOUND);if(s>=0){let r=this._originalMappings[s];if(void 0===e.column){const e=r.originalLine;for(;r&&r.originalLine===e;){let e=r.lastGeneratedColumn;this._computedColumnSpans&&null===e&&(e=1/0),t.push({line:util.getArg(r,"generatedLine",null),column:util.getArg(r,"generatedColumn",null),lastColumn:e}),r=this._originalMappings[++s]}}else{const e=r.originalColumn;for(;r&&r.originalLine===n&&r.originalColumn==e;){let e=r.lastGeneratedColumn;this._computedColumnSpans&&null===e&&(e=1/0),t.push({line:util.getArg(r,"generatedLine",null),column:util.getArg(r,"generatedColumn",null),lastColumn:e}),r=this._originalMappings[++s]}}}return t}destroy(){for(let e=0;e<this._sections.length;e++)this._sections[e].consumer.destroy()}}function _factory(e,n){let r=e;"string"==typeof e&&(r=util.parseSourceMapInput(e));const t=null!=r.sections?new IndexedSourceMapConsumer(r,n):new BasicSourceMapConsumer(r,n);return Promise.resolve(t)}function _factoryBSM(e,n){return BasicSourceMapConsumer.fromSourceMap(e,n)}exports.IndexedSourceMapConsumer=IndexedSourceMapConsumer;